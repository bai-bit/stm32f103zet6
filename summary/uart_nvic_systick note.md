# uart、nvic、systick 过程笔记

串口的配置：

​	1、查看数据手册，查找GPIO引脚定义，找到USART的定义，看看它的收发引脚是用的哪两个GPIO引脚。

​	2、查看电路图，找到对应的GPIO引脚，看看RX和TX的引脚是否和数据手册一致。防止出错。

​	3、查看时钟框图，查看对应的串口和GPIO引脚挂载在哪一条总线上。

​	4、配置对应的GPIO引脚，并使能时钟，RX和TX的模式。

​	5、配置对应的串口，并使能串口时钟。

​	6、配置串口的中断触发方式，并使能串口中断方法。

​	7、使能串口。

​	8、配置NVIC、串口中断处理函数的抢占和相应优先级，并使能对应的串口号中断。

​	9、编写串口中断处理函数。

过程中出现的问题：

​	1、在编译时，提示“对于xxx函数，没有足够信息导出符号表”

​		解决：先查看函数所在的文件是否添加到工程中，然后查看头文件是否依赖。头文件的名称是否输入正确。头文件的路径是否添加到工程中。

​	2、第一次编译通过，串口却无法正常工作。

​		排查：在程序运行时，打开led灯，在串口中断处理函数中添加关灯处理。

​			用串口调试助手向开发板发送一个字符，led灯无反应。

​			结论：没有触发中断，没有进入中断处理函数。

​		解决：查看串口板和开发板的连接是否正确，串口板的RX接开发板的TX，串口板的TX接开发板的RX.

​			排查代码，先排查GPIO口的配置，

​				RX:接收引脚，PA10,配置：复用推挽输出，speed为50MHz，

​				TX：发送引脚，PA9,配置：浮空输入模式，无speed频率。

​				使能GPIOA组的时钟，挂载在AP2总线上。

​			然后是串口的配置：波特率：115200，一个停止位，8位字长，无奇偶校验位，收发工作模式，无硬件流控制。

​                       串口中断触发方式：接受中断使能，

​			排查串口号的中断使能：查看启动文件，对应的中断处理函数名USART1_IRQHandler。

​			中断处理函数：在这里需要判断到来的串口中断是不是我们需要的中断，因为我们有可能会使能好几个不同的串口中断。查看我们的接收函数是否正确。

​		原因：硬件连线错误，位置不对，查看电路图，找到串口的输出引脚，连接之后，成功进入中断。小灯有了变化。

​		总结：排查代码过程中，我将涉及到算法的地方，直接改成配置相应的寄存器，然后编译，下载。发现还是不行，然后重头开始新一轮的排查，发现硬件连接位置不对。

​	3、写一个串口打印函数，本来是想写一个printf函数，但是这个函数需要重新定义，看了好多资料，说是直接用就行。没有详细的解释。

​		我水平太菜，居然没看懂。（(lll￢ω￢)）。然后我自己写了一个log_uart（）这么一个串口打印函数。缺点就是只能给它传递字符串。不能打印数字。

​		所以，我有写了一个itoa的函数，先把数字转换成字符串，然后在调用log_uart()函数打印。log_uart()函数调用了一个call_back_send()函数。

```C
void log_uart(uint8_t uartnum,char *buf)
{
	u8 send_buf[UART_SIZE];
	uint32_t i;
	for(i=0;i<UART_SIZE;i++)
	{
		send_buf[i] = *buf++;
		if(send_buf[i] == '\0')
				i=UART_SIZE;
	}
	for(i=0;i<UART_SIZE;i++)
	{
		call_back_send(uartnum,send_buf[i]);
		if(send_buf[i] == '\0')
			i = UART_SIZE;
	}
	
}

void call_back_send(uint8_t uartnum,char ch)
{
	while((uart_list[uartnum]->STS &0x80) == 0)
		continue;
	uart_list[uartnum]->DT =(uint8_t) ch;
}

char *itoa(uint32_t num)
{
	//定义一个数组，用来存放字符
	//把传递过来的数值，对十取取余，把得到的数字加‘0’，然后存放到数组中
	//不考虑负数的情况
	//最后将数组反转，末尾加’\0‘
	//return str
	char str[64] = "";
	static char str1[64] ="hello";
	uint32_t i = 0,j = 0;
	
	for(i = 0;i < 64 && num >= 1;i++)
	{
		str[i]=num%10 + '0';
		num /= 10;
		
	}
	while(i>0)
	{
		str1[j++] = str[i - 1];
		i--;
	}
	str1[j] = ' ';
	str1[j+1] = ' ';
	str1[j+2] = '\0';

	return str1;
}
//上面的代码，有些地方很粗糙。我会继续优化，越精简越好。
```



​	4、然后在一个技术大牛的提示下，写了一个获取时钟频率的函数。我给它起名为：getclock_frequency()!

​		输入一个clock名称，用一个枚举把它们集合到一块：systemclock,hclk,pclk1,pclk2,hse,hsi,lse,lsi,pll。

​		然后经过处理，返回一个对应的时钟频率。

​		返回的这个时钟频率，干啥用呢？

​		原来啊，在计算串口波特率的时候，需要获取到总线的时钟，然后根据传递过来的baud值，计算出USART->BRR的值。我一开始用的是官方的库函数。

​		现在不需要了，有了这个函数就不用官方的库函数了。

​		思路：先获取相应时钟的分频系数，然后用SystemCoreClock的值除以相应的分频系数，得到的值就是对应的时钟频率。

​		但是有的频率就不能通过上面的算法得到，比如HSI,LSE,LSI,只能是看数据手册，然后把值直接写进去。

​		这一块主要是分频系数的获取：AHB和APB的分频系数可以通过寄存器直接获取，然后定义几个宏定义。宏定义对应相应得分频系数，因为这几个分频系数相对较少。

​		但是PLL的倍频系数就不能这么做了，写宏定义太麻烦，从2倍到64倍，太多了，而且在寄存器中的位数设置也不再一块。在RCC->CFR中，分别用[30:19]和[21:18]两块区域一共

​		六个位来设置。通过查看数据手册，利用他们之间的规律，写了一个算法，来获取PLL的分频系数：

```C
	pll_frafremask = (PLL_FRAMASK & RCC->CFG); 
	//分频计算
	//将pll_frafremask的值与上0x6000 0000；把这个值右移25位
	//将pll_frafremask的值与上0x003c 0000；把这个值右移18位
	//然后将上的两个值相或，根据结果加一来确定分频系数。
	pll_value1 = pll_frafremask & 0x60000000;
	pll_value2 = pll_frafremask & 0x003c0000;
	
	if((pll_value = (pll_value1 | pll_value2)) == 0)
		pll_frafreval = 2;
	else if(pll_value < 50 && pll_value > 1)
		pll_frafreval = pll_value + 1;
	else
		pll_frafreval = pll_value - 1;
```



​	5、SysTick中断

​		通过查看启动文件，发现SysTick中断属于内核中断，不用设置NVIC。

​		通过查看cotex-M4内核数据手册，将SysTick->CSR寄存器的第二位置一，就可以使能SysTick中断。

​		然后查看启动文件，查看SysTick中断的处理函数符号，然后用该符号作为中断处理函数名，写一个函数。

​		在技术大牛的指点下，写了一个利用SysTick中断，向电脑每隔100ms打印一个数字，打印一次，数值自增1。

​		出现的问题：串口调试助手的窗口无反应。

​			排查：首先是串口调试助手的串口开关打开，波特率正确。硬件连接正常。

​			向板子发送字符无反应。

​			怀疑原因：延时函数出现问题了。

​			排查：注释掉串口代码。在while（1）里边写了一个led闪烁。

​			现象：led常亮，延时函数出现问题。排查延时函数的代码。包括delayinit，delayms，delayus。

​			原因：在检查delayinit函数时，发现传递的参数不对。应该是我自己定义的宏定义：

```c
#define SYSTICK_SOURCE SystemCoreClock
```

​			或者是getclock_frrquency的返回值。但是这个时候，delayinit的参数不是这两个。编译也没有提示错误。

​			修改代码，重新编译。下载hex文件。led灯成功闪烁。用逻辑分析仪查看波形，延时是否精准，延时500ms，实际是0.49995s。误差可以接受。

​			取消串口代码的注释，把led的代码注释掉。编译，下载hex文件。打开串口调试助手，成功显示不断递增的数值。



最后:在编写的过程中，最容易出错的就是一些__赋值运算__和__或与非__的运算,尤其是在配置寄存器的过程中。