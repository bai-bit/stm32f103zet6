1.宏定义的使用：函数块中，不应该出现数值，应该使用宏定义，一方面是便于后期阅读代码，一面放是便于后期的修改。

2.代码的对齐：同一级的代码，应该左对齐，便于代码的阅读。

3.extern关键字的使用，变量在进行外部引用的时候，需要用到extern关键字来告诉编译器，extern后边的变量是外部引用，不进行内存分配，如果后边跟着初始化值，那么前的extern关键字就会被编译器忽略，把这个变量变成了定义，重新分配内存。程序也会出现不可预知的情况。

4.变量的位置，头文件的使用：变量一般定义在“.c”文件中，便于阅读代码。头文件中一般包含的是一些宏定义，结构体，枚举体，联合体的模板。函数原型声明。

5.三目运算符的使用，简化代码。有些场景需要判断0和非0的执行选择，这个时候用三目运算符比用if。。。else。。要简洁。

6.独立完成外设的库函数，独立完成外设库函数的封装，对于理解硬件，软件的执行逻辑有很大的帮助，

7.尽可能的少使用结构体，因为单片机的代码不会有太多的数据，在传递参数比较少的情况下，尽量逐个传递，只有在需要传递的参数很多的时候，可以考虑使用结构体。

8.单片机的代码尽可能的精简，单片机代码比较简单，不会要求复杂的动作，同时要求处理的速度要快，所以代码尽可能的简洁。

9.systick函数使用的内核时钟源和传入的时钟频率不能完全控制。应该在始终初始化函数中，添加判断代码，根据systick的时钟源的选择对传入的时钟频率进行分频。

10.一些存储数据的寄存器，需要考虑数据宽度和溢出的问题，比如systick->load寄存器，数据宽度是24位，当需要装载的数值过大的时候，他就会溢出，造成实际装载的数值和期望值不一致。延时不准确。

11.自己编写的函数，开头要添加几个特别的大写字母，不要和官方库函数名一致。以免在编译时发生冲突。

12.talite关键字：防止编译器对变量或函数进行优化。

​				告知编译器，修饰的变量是易变的，再使用的时候，不要使用处理器内部寄存器（r0-r7）保存的临时值，需要到变量的存储区重新获取新值。

13.全局变量不用初始化，局部变量尽可能的初始化。

14.每次修改完代码，就进行一次编译，便于及时查看修改完之后的变化。根据新的编译提示，再进行更改代码。

当编译0 error的时候，把代码下载到开发板上进行测试。然后根据实际的反应在修改代码，直到实际的行为符合要求。最后，在编译0 error的情况下，把警报也要修改到0 warning。

15.在写代码时，要仔细考虑代码的运行逻辑。要仔细查看数据手册。比如if。。。else的判断条件，while，do。。。while的判断条件，如果不仔细考虑代码的运行逻辑，就很容易出错。例如：

```c
do{
			temp = SysTick->CTRL;
		}while((temp & 1) && (SysTick->VAL != 0));
//这三行代码，在第三行，有一些问题，首先是不能出现数字，应该把0和1，改为相应的宏定义。让其他人一看就知道是什么意思。然后就是判断条件，因为load寄存器是递减计数器，从装载值一直递减到0，所以的我的想法是当load递减到0时，结束while循环，但是，load递减寄存器是一个重装载递减计数器，当它递减到0时，他会重新从装载值递减，如果当while的判断到来时，load的值不为0，或者时load的值为0时，但是while的判断没有到。就会出现误差。从而造成延时不够精准。
//所以，通过查看数据手册，判断条件需要修改。
do{
    temp = SysTick->CTRL;
    }while((temp & 0x01) && !(SysTick->CTRL & (1 << 16) ))
```

时间：2019年9月30日